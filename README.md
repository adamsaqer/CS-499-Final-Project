# Adam Saqer – CS 499 Computer Science Capstone Portfolio

*Welcome to my capstone portfolio. This repository contains an enhanced Java-based **Rescue Animal Management System** that showcases my skills in software design, algorithms, and database management developed during my journey at SNHU.*  

## Table of Contents

- [Professional Self-Assessment](#professional-self-assessment)  
- [Software Design & Engineering Enhancements](#software-design--engineering-enhancements)  
- [Algorithms & Data Structures Enhancements](#algorithms--data-structures-enhancements)  
- [Database Enhancements](#database-enhancements)  
- [Conclusion](#conclusion)  
- [Contact Information](#contact-information)  

## Professional Self-Assessment
Hello, my name is Adam Saqer, and welcome to my CS 499 Capstone Portfolio. I come from a background in operations, where I honed skills in process optimization and team collaboration. Transitioning into the Computer Science program at SNHU has allowed me to channel that operational insight into software development practices. Over the course of this program, I have grown from writing simple scripts to engineering complex systems, always emphasizing clarity, efficiency, and teamwork. 

This portfolio is a culmination of my academic journey and professional growth. It showcases three enhanced software artifacts that demonstrate my competencies in Software Design & Engineering, Algorithms & Data Structures, and Databases. Each project has been carefully chosen and improved beyond its original state to highlight my mastery of key skills and to address all five core course outcomes of the Computer Science program. 

I am proud to present this work as evidence of my ability to design robust applications, implement efficient algorithms, manage data effectively, and communicate technical concepts clearly. Throughout the enhancement process, I leveraged my operations experience by approaching problems with a systematic and detail-oriented mindset. I collaborated with peers and mentors to review code and integrate feedback, reflecting a professional practice of iterative improvement. I also maintained a strong focus on software security and data privacy, ensuring that each artifact not only works correctly but is also safe against common vulnerabilities. 

This portfolio stands as a comprehensive self-assessment of my skills: it demonstrates where I started, how I have grown, and how I can contribute as a software developer in a professional setting.

## Software Design & Engineering Enhancements

**Artifact Description:** The Rescue Animal Management System was originally created in an earlier SNHU course as a simple Java console program to track rescue animals (dogs and monkeys) and their training status. Initially, the code functioned but was basic in design – it had limited error handling, and some logic was clumped together, making it less maintainable. For the capstone, I targeted this artifact for **Software Design & Engineering** enhancements to improve its structure, readability, and maintainability. The goal was to refactor the program using best practices in object-oriented design and clean code principles while preserving all original functionality.

**Enhancements Made (Design & Code Quality):**

- **Refactored Class Structure:** Ensured a robust object-oriented design by utilizing a base class `RescueAnimal` with subclasses `Dog` and `Monkey`. This inheritance structure (some of which existed in the original version) was reviewed and refined to eliminate redundancy. By having common attributes in the base class (name, age, etc.) and specific attributes (like `breed` for dogs, `species` and measurements for monkeys) in subclasses, the design follows the **Single Responsibility Principle** and makes the code easier to extend in the future (for example, adding new animal types).
- **Improved Organization and Modularity:** Broke down the monolithic logic into well-defined methods. The menu-driven workflow in the `Driver` class is now supported by separate functions such as `intakeNewDog()`, `intakeNewMonkey()`, `reserveAnimal()`, and `printAnimals()`. Each method has a clear purpose, which improves readability and simplifies debugging. This modular approach means new features or changes can be made with minimal impact on other parts of the code, demonstrating **encapsulation** and thoughtful software engineering.
- **User Input Validation & Error Handling:** Added comprehensive input validation to make the system more user-friendly and robust. For example, when adding a new animal, the program now checks for empty inputs and duplicate names, and ensures the monkey’s species is one of the allowed types. Invalid inputs trigger informative messages instead of causing exceptions or incorrect data states. This enhancement not only improves the user experience but also reflects defensive programming practices important in professional software development.
- **Persistent Data Design:** (Cross-listed with the Databases category, but also a design decision) Implemented a mechanism to save and load animal data to a file. From a design standpoint, this required planning how to represent animal records in a flat text format and where to integrate file I/O in the program flow. I designed a simple CSV schema for animals and built the persistence functions (`saveData()` and `loadData()`) in a way that keeps them decoupled from the core logic. This separation means the core features (like intake or reservation) don’t need to know about file details, adhering to a cleaner layered design.
- **Code Documentation and Style:** To improve maintainability, I updated and expanded code comments (Javadoc-style) for classes and methods to clearly explain their purpose. I also reformatted code for consistency (proper indentation, spacing, and naming conventions). These changes may not affect runtime behavior, but they significantly improve the **readability and professionalism** of the code, which is crucial in a team environment or when handing the project off to another developer.

**Course Outcomes Met:** These software design enhancements demonstrate my ability to **design, develop, and deliver maintainable software solutions** (CS program outcome related to Software Engineering). I applied industry standards in modular design and documentation, which aligns with the outcome of producing professional-quality software artifacts. By performing a code review and refactoring the codebase systematically, I also practiced **collaborative and analytical skills** akin to real-world development workflows (identifying issues and iterating on solutions). In summary, this artifact showcases my competency in **software design principles, code organization, and quality assurance**, meeting the expected outcomes for the Software Design & Engineering category.

**Reflection:** Enhancing the design of this program taught me valuable lessons about working with an existing codebase and making iterative improvements. One challenge I encountered was ensuring that my refactoring didn’t introduce new bugs. To overcome this, I adopted an incremental approach: after each change, I reran and tested the relevant functionality (for instance, after modifying the intake logic, I would add a new dog and monkey to verify everything still worked). This experience reinforced the importance of regression testing and careful planning when improving software design. I also learned how crucial clear structure is for a project’s long-term success – as I cleaned up the code, I found it much easier to add new features, which validated the effort spent on refactoring. Overall, I gained confidence in applying object-oriented design principles and realized that writing clean, well-documented code upfront makes future enhancements and maintenance far smoother. This reflection will stay with me as I move into my professional career, where I’ll likely work with and improve legacy codebases.

## Algorithms & Data Structures Enhancements

**Artifact Description:** In the original Rescue Animal Management System, the algorithmic logic was straightforward, suitable for a small-scale assignment but not heavily optimized. Data was stored in basic collections without any advanced data structure use beyond lists, and operations like searching for an available animal were done with simple loops. For the **Algorithms & Data Structures** category, I focused on making the program more efficient and reliable through better choice of data structures and refined algorithms. These enhancements ensure that the system can handle data more effectively and lay the groundwork for scalability and performance improvements.

**Enhancements Made (Efficiency & Data Handling):**

- **Efficient Data Structures:** Introduced a `HashSet<String>` to track animal names in the system. Originally, to ensure no two animals had the same name, the code would have had to loop through both the dog list and monkey list for each new intake. By using a HashSet (`animalNames`) that stores all names in lowercase, we achieve constant time look-ups for duplicate checks. This is a classic example of choosing the right data structure to optimize an algorithm (checking for a name's existence). It not only simplifies the code (one containment check replaces two list traversals) but also improves performance, especially if the number of animals grows large.
- **Improved Search Algorithm for Reservations:** The reservation functionality (`reserveAnimal`) was enhanced to find the first available animal of a given type and location. While the logic still uses a loop, I ensured it breaks out as soon as a suitable animal is found. This small algorithmic tweak prevents unnecessary iterations once the task is complete. In a scenario with many animals, breaking early can improve efficiency. The design also cleanly separates the search for dogs and monkeys, making the code easy to follow. If the dataset grew, this approach could be further optimized (for instance, by indexing animals by location), but for the current scope it is efficient and clear.
- **Input Validation Loops:** Certain inputs, like the monkey's species, now use a loop to repeatedly prompt the user until a valid response is given. This is an algorithmic improvement ensuring data integrity. Instead of accepting invalid data or terminating, the program uses a **while loop** to enforce rules (only allowed species can be entered). This not only prevents errors downstream (e.g., avoiding a situation where a monkey has an undefined species) but also exemplifies a robust algorithm for input handling. The loop continues until the condition is met, which is a simple but effective use of algorithmic thinking to guarantee correctness.
- **Use of Inheritance and Polymorphism in Data Handling:** By leveraging the inheritance hierarchy (RescueAnimal -> Dog/Monkey), the code implicitly uses polymorphism when printing animal details. Each subclass has its own `toString()` implementation (for formatted output), and the printing algorithm simply calls `toString()` on each animal object. This is an elegant use of object-oriented principles to simplify the algorithm: the `printAnimals` method doesn’t need complex logic to format each type differently; the decision is made by the object’s class. This demonstrates how a good design (Software Engineering aspect) directly benefits algorithm simplicity and clarity.
- **Complexity Consideration:** I analyzed the algorithmic complexity of key operations. For example, listing available animals now iterates through the lists once, and duplicate name checking is O(1) with the hash set. Given the expected usage of the system, these operations are very efficient. In enhancing the code, I kept an eye on not introducing any algorithm with worse complexity. All enhancements either maintain or improve the original performance. This attention to efficiency meets the goal of writing algorithms that scale and is indicative of a strong grasp of data structure choices.

**Course Outcomes Met:** The algorithmic enhancements meet the program’s outcome of **applying algorithms and data structures to solve problems effectively**. By optimizing name look-up with a hash set and refining search loops, I demonstrated the ability to improve computational efficiency and reasoning about algorithmic complexity (an essential computer science outcome). Additionally, this artifact shows **problem-solving skills** – I identified potential inefficiencies or issues (like how to prevent duplicate entries or handle invalid input) and resolved them using appropriate structures and control flows. These changes align with the outcome of designing computing solutions with well-founded algorithmic principles. In essence, the project now embodies cleaner, more efficient code which is exactly what the Algorithms & Data Structures outcome is about: choosing the right approach to handle data and operations for correctness and performance.

**Reflection:** Working on the algorithms and data handling of this project was a great exercise in critical thinking and attention to detail. I learned that even in a small program, the choice of data structures can have a significant impact on clarity and efficiency. A key challenge I faced was ensuring that new algorithmic additions (like the duplicate name check) integrated well with existing logic. For instance, when I added the `animalNames` HashSet, I had to carefully update the intake methods and data loading function to populate this set everywhere an animal is added. If I missed an insertion, the set and the lists could go out of sync, leading to bugs. Through diligent debugging and testing (adding various animals and verifying that duplicates were caught every time), I overcame this challenge. I also gained a deeper appreciation for writing algorithms that handle edge cases: testing scenarios such as "no animals in the system", "all animals reserved", or "invalid inputs repeatedly" helped me refine the loops and conditions. These experiences improved my ability to reason about program state and transitions, which is at the heart of algorithmic thinking. Overall, this enhancement process reinforced my confidence in using data structures like lists and sets appropriately, and in constructing algorithms that are both **correct and efficient**. I will carry forward these skills, knowing that thinking through the data and logic early leads to more robust code.

## Database Enhancements

**Artifact Description:** Originally, the Rescue Animal Management System managed its data in-memory only; whenever the program exited, all records were lost. There was no true database or persistence mechanism in the initial version. For the capstone’s **Databases** category, I introduced a form of data persistence to simulate a database, ensuring that animal data is stored between sessions. While a full-fledged relational database might be beyond the scope of this small application, implementing file-based persistence was a significant step toward demonstrating database design principles. It required deciding how to store the data (schema), how to read/write efficiently, and how to ensure data integrity, similar challenges one faces when working with databases.

**Enhancements Made (Data Persistence & Integrity):**

- **Persistent Storage (File I/O):** I implemented saving and loading of data to a file (`animals.txt`) to serve as a simple database for the application. Now, whenever the program runs, it attempts to load existing animal records from this file, and upon exit, it writes all current data back to the file. Each animal is stored as a comma-separated line (CSV format). For example, a dog record is saved as:  
  `Dog,Name,Breed,Gender,Age,Weight,AcquisitionDate,AcquisitionCountry,TrainingStatus,Reserved,InServiceCountry`  
  This flat-file database approach ensures that users (or testers) don’t have to re-enter data each time, greatly increasing the usefulness of the system. It also demonstrates an understanding of how data can be persisted outside of the program’s runtime.
- **Schema Design and Parsing:** Designing the format for the file was an important step. I decided on including a leading identifier (e.g., "Dog" or "Monkey") on each line, so the loader knows which object type to reconstruct. Dogs have 10 fields following the identifier (for a total of 11 comma-separated values), and monkeys have 13 fields (total of 14 values). I wrote the `loadData()` function to parse each line based on this schema, carefully handling potential issues like missing fields or extra commas. The use of `String.split()` with a limit, and checks on the length of the resulting array, ensures that malformed lines are caught or ignored gracefully. This is analogous to defining a table schema in a database and writing queries to transform query results into objects – it’s manual here, but the concept is similar to ORM (Object-Relational Mapping) on a smaller scale.
- **Data Integrity & Consistency:** When implementing the save and load features, I was mindful of maintaining data integrity. For instance, the program uses the same format consistently; any animal saved to file will be correctly loaded on the next run. I included logic to handle default cases: if the data file doesn’t exist, the program initializes a set of default animals (so a first-time user isn’t starting from scratch with an empty system unless desired). If the file exists but has no data or incomplete data, the loader safely skips bad entries to avoid crashes. Moreover, each time an animal is added via the intake functions, it is immediately reflected in the in-memory lists and also added to the `animalNames` set for consistency. By centralizing the save and load operations, I made it easier to ensure the data in memory and the data on disk remain consistent. These are core concerns in database management – atomicity and consistency – which I addressed in a simplified context.
- **Use of Try-With-Resources and Exception Handling:** In the file reading/writing methods, I employed try-with-resources and proper exception handling to manage file streams. This ensures that file handles are closed automatically and any I/O errors are caught. For example, if saving data fails (say, due to file permission issues), the program catches a `FileNotFoundException` and prints an error message instead of silently failing or crashing. This level of error handling is akin to handling database connection errors or failed transactions in a larger system. It was an important enhancement to make the application more robust and closer to production quality in terms of how it deals with external data sources.
- **Foundation for Future Database Integration:** While the current enhancement uses a text file, I structured the persistence layer with the possibility of future expansion in mind. The separation of `saveData()` and `loadData()` as dedicated methods means that swapping out the file system for a real database (e.g., MySQL or SQLite) in the future would localize changes mostly to those areas. In other words, I treated the file as a stand-in for a database; the rest of the application (intake, reserve, print functions) operates on in-memory objects and doesn’t need to know where the data comes from or goes to. This abstraction is a good design practice and mirrors how applications use a database layer. It shows that I understand how to incorporate a database into software architecture and the importance of isolating database-specific code.

**Course Outcomes Met:** By adding a persistence layer, I addressed the outcome of **managing and utilizing data storage systems in software solutions**. In the context of the program, this means I demonstrated the ability to design a simple database (in file form), interact with it through code, and ensure data is correctly stored and retrieved – all fundamental database concepts. This enhancement also touched on the **security and data integrity** aspect of the curriculum: I had to consider how to avoid corrupting data, handle improper input (which could be seen as a rudimentary defense against malformed data or even injection if this were expanded to a real DB), and maintain user trust that their input (animal records) will be saved reliably. Although not a full SQL database, working with file I/O gave me a smaller-scale experience of many challenges that databases pose, fulfilling the intent of the Databases outcome. I also practiced writing clear documentation for data formats and handling exceptions, which aligns with producing quality software that safely handles resources and errors – a key professional skill when dealing with persistent data.

**Reflection:** Incorporating a pseudo-database via file persistence was a rewarding challenge. Initially, I was unfamiliar with the nuances of Java file I/O in this context, so I researched how to use `Scanner` for reading files and `PrintWriter` for writing files efficiently. One challenge was deciding on a data format that would be both human-readable (for debugging) and easy to parse. I iterated over a couple of designs and eventually settled on the CSV approach, which balanced simplicity and clarity. Testing this feature was another learning experience: I created various scenarios, such as adding multiple animals and restarting the program to ensure they all load correctly, or manually editing the `animals.txt` file to inject subtle errors and seeing if my `loadData()` could handle them. Through this testing, I improved the robustness of the parsing logic. I also learned the importance of backing up data before making changes; while developing the save function, I kept a backup of the sample file in case a bug in my code overwrote it incorrectly. This is analogous to how one would approach updating a real database with caution (e.g., not running destructive operations without backups). Overall, this enhancement deepened my understanding of how persistent storage works and how crucial it is to handle data carefully. I feel more prepared to work with actual databases now, having practiced on this smaller scale, and I’m confident in my ability to integrate data management solutions into future projects.

## Conclusion

Completing the CS 499 Capstone project has been a fulfilling culmination of my academic journey. By revisiting the Rescue Animal Management System and infusing it with enhancements, I was able to tangibly demonstrate the skills and knowledge I've gained in software engineering, algorithms, and database management. The process demanded careful planning, diligent coding, and thoughtful reflection – all of which mirror the real-world software development cycle. I am proud of the professional and polished state of this project. It not only meets the capstone requirements but also serves as a portfolio piece that showcases my technical competency and growth as a developer.

This project has shown me how far I've come since I started the program. Challenges that once seemed daunting – like refactoring code or handling file I/O – are now opportunities for me to apply best practices and creativity in problem-solving. The enhanced Rescue Animal Management System is more than just an assignment; it’s a demonstration of my readiness to contribute to professional software projects. I have learned how to learn, adapt, and continuously improve, which I believe are the most important takeaways from any educational endeavor. 

Thank you for taking the time to read through my work. I’m excited to carry these experiences forward into my career, building solutions that are efficient, reliable, and impactful. Please feel free to explore the code in this repository, and don't hesitate to reach out if you have any questions or would like to discuss my work further.

## Contact Information

**Email:** [adam.saqer@example.com](mailto:adam.saqer@example.com)  

*(Please reach out via email for any professional inquiries or further information about this project. I welcome opportunities to discuss the work or potential collaborations.)*
